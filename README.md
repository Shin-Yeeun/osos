# osos
First I made  and target.c, solution.c, pctest.c. Testdir contains 10 inputs of the test, and target.c puts the input received from the testdir and runs it. The solution is the same as target. Now, let me explain about pctest.c. First, I declared the pipe global variable. And the child_proc_tar function first gets the file name and input value from the main function. Then declared the process of target_pid through pid_t, which specifies the process number. Then, run the system by forking target_pid. The child process compiles the target file, and the parent process executes the target's file. When you run and compile, you do it through execl. First, if you look at the child process, it runs when target_pid is zero, handing over the executable, target, and file name. And in the parent process, it is executed by handing over "./target" and the input received. 
The solution function is similar to the target, but instead of the target, the solution is inserted and executed.
Now, let me explain the main function. The process was named Child Process, and exit_code was declared. We also declared a directory containing inputs and an elem to read the files in the directory. Then declare array to save inputfile name inside, and open and save the testdir entered when running the file through openir. 
If there is nothing in the input file, read the input file through readdir and put it in the email first. And put the file name of the elem in the array of input_file. Then, add the i and 1 and put it in the array index. If there is nothing in test directory, we end with print No directory. So I was able to learn how to do openir at first.
Create a process under the name Child_pid, read 10 files through the for statement, and read text and dir. 
According to the results of the previous print, file0 doesn't contain anything, so start with 1. Put the name of the file in Char and read the files you received through open. Declare string to receive input from test file and save it to str used fgets. To use pipe, I declare buf and declare pipe. Insert the global variable of the pipe you created earlier into the pipe function. And run the system by forking the child_p process. In the child process, we use the pipe and call the target child function, and if we look at the pipe first, when the pipes are 1 in the write, we write the contents on the pipe, and we put the str we got from Input into the pipe and size it is used on the pipe. Then, put the target file in the child_target function, and put the string that you received from the input. And in the parent process, the string that you handed over to the pipe is used in the read function and the pipe [0] is used to get that size in the buffer. And you have to wait in the parent process so that you don't finish the main part of the child process right away, so you just hand over the buf and solution you received earlier to the sol. And close the dir. Let's print and see if it went well. I've checked that it's going well. 

While doing this task, I didn't get to do more than 10 simple things, so I didn't do much afterwards, but I'll explain how to compare one by one by one. First, there's a way to save the target and solution results in a text file and write a pipe. First, the method of writing a text file writes two results to a file, reads the two and compares them, then prints that they are not the answer if they are not the same. The method of writing on a pipe is similar, but it is a method of reading and comparing the results through the read of the pipe. And I have to get the error, but if exit is 1 in dup2, I can't read it, so I draw the error, if 2 it just says error, and if 0 it keeps going back.  And after each turn, you measure the time and kill if it's over time, and you get an error. The method of measuring this time is completed using Signal.
Through this task, I learned that my coding skills were very poor, but I still tried to understand the algorithms of the operating system, so I learned about the system. I didn't know how to start with problem understanding and coding, but I think I was able to do this much because I tried to solve each of the coding that the professor gave me.
